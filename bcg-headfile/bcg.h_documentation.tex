\documentclass[a4paper]{article}

\usepackage[table]{xcolor}%this has to be the first!!!!!!
\usepackage{fullpage} % Package to use full page
%\usepackage{parskip} % Package to tweak paragraph skipping
\usepackage{tikz} % Package for drawing
\usetikzlibrary{shapes,arrows,matrix,positioning}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{subcaption}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{minted}
\usepackage{multicol}
%color define
\definecolor{codebg}{RGB}{230,255,253}
\definecolor{function}{RGB}{210,0,26}
\definecolor{para}{RGB}{255,137,137}
\definecolor{output}{RGB}{238,224,201}
\setminted[cpp]{mathescape=true,breaklines,bgcolor=codebg,linenos}

\tikzset{
  block/.style = {rectangle, draw, fill=output, text width=6cm, text centered, rounded corners, minimum height=4em},
  line/.style = {draw, -latex'},
}


%function newcommand
\newcommand{\func}[1]{\textbf{\textcolor{function}{#1}}}
\newcommand{\para}[1]{\textbf{\emph{\textcolor{para}{#1}}}}

\usepackage{biblatex}
\addbibresource{bibliography.bib}
\title{bcg.h Documentation}
\author{Haochen(Langford) Huang}
\date{\today}

\makeatletter%title setting
\def\@maketitle{%
  \newpage
  \null
  \vskip 2em%
  \begin{center}%
  \let \footnote \thanks
    {\LARGE \@title \par}%
    \vskip 1.5em%
    {\Large
      \lineskip .5em%
      \begin{tabular}[t]{c}%
        \@author
      \end{tabular}\par}%
    \vskip 1em%
    {\large \@date\par}%
    \vskip 1em%
    {\large version:2.0}%
  \end{center}%
  \par
  \vskip 1.5em}
\makeatother

\begin{document}

\maketitle

\section{Introduction and Background}\label{sec:intro}
\textbf{bcg.h} file contains two functions: \textcolor{red}{\emph{tracer\_fluxes}} and \textcolor{red}{\emph{advection}} whose major purpose is to construct a solver for advective equation:
\begin{equation}
  \frac{\partial \Phi}{\partial t} + ( \mathbf{u} \cdot \nabla)\Phi = 0\label{equ:aim}
\end{equation}
where $\Phi$ is the scalar and $ \mathbf{u}$ is the velocity. The discrete time formulation of equation \ref{equ:aim} reads:
\begin{equation}
  \frac{\Phi^{n+1}-\Phi^{n}}{\Delta t} + \mathbf{A}^{n+\frac{1}{2}} = 0 \label{equ:general}
\end{equation}
Where $ \mathbf{A}^{n+ \frac{1}{2}}$ is the abbreviation of advection term. With the conservative constraints $\nabla \cdot \mathbf{u} = 0$, the integral form reads:
\begin{equation}
  \int_{\Gamma} A^{n+ \frac{1}{2}} = \int_{\Gamma} [( \mathbf{u}\cdot \nabla)\Phi]^{n+ \frac{1}{2}} = \int_{\Gamma} [\nabla\cdot( \mathbf{u} \Phi)]^{n+ \frac{1}{2}} = \int_{\partial \Gamma} ( \mathbf{u}^{n + \frac{1}{2}} \cdot \mathbf{n}) \Phi^{n+ \frac{1}{2}}
\end{equation}
where $ \mathbf{n}$ represents the normal direction of cell interface. For cartesian cell employed in Basilisk, the calculation turns out to be
\begin{equation}
  \Delta A^{n+ \frac{1}{2}} = \sum_{d} s_d u_{f,d}^{n+ \frac{1}{2}}\Phi_{f,d}^{n + \frac{1}{2}} 
\end{equation}
Note in this documentation, the subscript $f$ denotes face value stored in staggered mesh\cite{1965_Harlow}, otherwise it is cell-average value stored in center of the cell. Subscript $d$ is the notation of specific face ($e,w,n,s$ for 2D and $e,s,n,s,f,b$ for 3D) for a single cell. In addition, readers may found algebraic notation without $d$ such as $u_f$ in the upcoming discussion which refers to the same thing. This is because in the most cases $d$ is used to addressed spatial relationship between face and cell from cell-perspective, such relation shall vanish from face-perspective and so does $d$.

The following discussions are conducted under 2D condition and results of 3D is easily to obtain accordingly. $s_d$ represents sign function which reads
\begin{equation}
    s_d = 
    \left\{
    \begin{array}{cc}
    1\ \ d=e,n \\
    -1\ \ d=w,s
    \end{array}
    \right.
\end{equation}
The problem now becomes how to obtain $u_f^{n+1/2}$ and $\Phi_f^{n+1/2}$. Basilisk employs BCG scheme to tackle such issue. The scheme, which is originally named by three authors\cite{1989_Bell}, stems from the algorithm intending to apply second order Godunov method to incompressible flow. It obtains value at $n+\frac{1}{2}$ not by averaging but by considering the Taylor series, for each cell:
\begin{equation}
  \Tilde{\Phi}^{n+ \frac{1}{2}}_{f,d} = \Phi^n+ s_d\frac{\Delta}{2} \frac{\partial \Phi^n}{\partial x_d} + \frac{\Delta t}{2} \frac{\partial \Phi^n}{\partial t} + O(\Delta^2,\Delta t^2)
\end{equation}
Where $x_d=x$ for $d = e,w$ and $x_d=y$ for $d = n,s$. Replacing $ \frac{\partial \Phi^n}{\partial x_d}$ with Euler equation \ref{equ:aim} yielding 
\begin{equation}
  \Tilde{\Phi}^{n+ \frac{1}{2}}_{f,d} = \Phi^n + [s_d \frac{\Delta}{2}- \frac{\Delta t}{2} u_d] \frac{\partial \Phi^n}{\partial x_d} - \frac{\Delta t}{2} u_o \frac{\partial \Phi^n}{\partial x_o}\label{equ:taylor}
\end{equation}
where $u_d$ is the cell-centered value on $d$ direction (i.e. $u_x$ for $d = e,w$, $u_y$ for $d = n,s$). Subscript $o$ represents directions other than $d$.
Since aiming equation \ref{equ:aim} is advection-only, a simple upwind scheme is therefore employed\cite{2000_Martin,1998_Martin} to adapt each term in equation \ref{equ:taylor}:
\begin{align}
  \Tilde{\Phi}^{n+ \frac{1}{2}}_{f,d} &= \Phi^n + [s_d \frac{\Delta}{2}- max(\frac{\Delta t}{2} u_d,0)] \frac{\partial \Phi^n}{\partial x_d} - \frac{\Delta t}{2} u_o \overline{\frac{\partial \Phi^n}{\partial x_o}}\label{equ:upwind} \\
  \overline{\frac{\partial \Phi^n}{\partial x_o}} &= \left\{
  \begin{array}{cc}
       (\Phi^n[0] - \Phi^n[-1])/\Delta&\ if\ u_o>0 \\
       (\Phi^n[1] - \Phi^n[0])/\Delta&\ if\ u_o<0
  \end{array}
  \right.\label{equ:upwind2}
\end{align}
If not additionally declared, $\frac{\partial \Phi^n}{\partial x_d}$ is computed with central scheme.
Given four face values from each cell, each face now has two values from its neighbor cell which are left value and right value in traditional Godunov method. Unlike the traditional method which obtains the final face value $\Phi_{f,d}$ by solving Riemann problem, the upwind scheme is again applied to determine $\Phi_{f,d}$ in current algorithm (the value is counted from each face hence the subscript $d$ is omitted.)
\begin{equation}
    \Phi^{n+1/2}_{f}[0] = \left\{
    \begin{array}{cc}
         \Tilde{\Phi_f}[0]\ \ &u^{n+1/2}_f<0\\
         \Tilde{\Phi_f}[-1]\ \ &u^{n+1/2}_f>0\\
         \frac{1}{2}(\Tilde{\Phi_f}[0]+\Tilde{\Phi_f}[-1])\ \ &u^{n+1/2}_f=0
    \end{array}
    \right.
    \label{equ:upwindfinal}
\end{equation}
where $u_f$ is velocity on the same face and marker $[0],[-1]$ indicate the cell from which the face value is obtained. In mesh system of Basilisk, for face located at $(i-1/2,j)$ the $[0]$ (resp. $[-1]$) represents cell positioned at $(i,j)$ (resp. $(i-1,j)$). It is worth mentioning that the marker in current equation is associated with the direction. For example, if one calculates face value $\Phi_f^{n+1/2}$ on $x$ direction, the marker in equation \ref{equ:upwindfinal} indicates the relationship on $x$ direction while those in equation \ref{equ:upwind2} refers to relation on $y$ direction. Above discussion is the original algorithm on the paper, compensation is made in real code which shall be introduced in the following sections.
\section{Functions}

\subsection{\func{tracer\_fluxes}}
Given face velocity $u^{n+1/2}_f$, the face flux $u_{f}^{n+ \frac{1}{2}}\Phi_{f}^{n + \frac{1}{2}}$ is computed and stored on staggered mesh.
\subsubsection{Parameters}
\begin{center}
  \begin{tabular}{|c|c|c|c|c|}
    \hline
    Name & Data type & Status & Option & Representation (before/after)\\[0.5ex]
    \hline\hline
    \para{f} & scalar & unchanged & compulsory & $\Phi^n$\\
    \hline
    \para{uf} & face vector & unchanged & compulsory & $u_f^{n+ \frac{1}{2}}$\\
    \hline
    \rowcolor{output} \para{flux} & face vector & \textbf{output} & compulsory & $u_f^{n+ \frac{1}{2}}\Phi_f^{n+\frac{1}{2}}$\\
    \hline
    \para{dt} & double & unchanged & compulsory & $\Delta t$\\
    \hline
    \para{src} & scalar & unchanged & compulsory & $ a^n$ \\
    \hline
  \end{tabular}
\end{center}

\subsubsection{Worth Mentioning Details}\label{sec:tracerdetail}
As discussed previously, specific face value on staggered mesh\cite{1965_Harlow} can be located by its spatial relation with corresponding cell. Take cell at $(i,j)$ as an example, figure \ref{fig:staggered} demonstrates notation of each face. Moreover such value can be iterated by calling macro $foreach\_face()$ in Basilisk. Thanks to this feature, the code can be constructed from face-perspective starting from equation \ref{equ:upwindfinal} rather than iterating every cell and compare two values for single faces.\par
Notably, different from original algorithm, two compensations are made in performing equation \ref{equ:upwindfinal} and equation \ref{equ:upwind} respectively. For the former one, the condition where $u_f^{n+1/2}=0$ merges into the second condition, the filter now reads:
\begin{equation}
    \Phi^{n+1/2}_{f}[0] = \left\{
    \begin{array}{cc}
         \Tilde{\Phi_f}[0]\ \ &u^{n+1/2}_f<0\\
         \Tilde{\Phi_f}[-1]\ \ &u^{n+1/2}_f\geq0
    \end{array}
    \right.
    \label{equ:upwindfinal2}
\end{equation}
For the latter one, $u_d$ is replaced by face value $u_f[]$ for simplicity in boundary condition settings. Consequently the upwind filter (i.e. the $max()$) is no longer needed in the second term of equation \ref{equ:upwind} since upwind scheme is automatically met owing to upwind selection originally conducted by equation \ref{equ:upwindfinal2}. 

\begin{figure}[H]
     \centering
     \begin{center}
     \begin{tikzpicture}[scale=1]
     \draw (-2,0)--(2,0)--(2,4)--(-2,4)--(-2,0);
     \node at (0,0) [anchor=north]{ $\Phi.y[i]$ };
     \node at (-2,2) [anchor=west]{ $\Phi.x[i]$ };
     \node at (2,2) [anchor=west]{ $\Phi.x[i+1]$ };
     \node at (0,4) [anchor=north]{ $\Phi.y[i+1]$ };\
     \node at (0,2) {$[i,j]$};
     \end{tikzpicture}
     \end{center}
     \caption{Example of staggered mesh.}
     \label{fig:staggered}
\end{figure}
Given $u_f^{n+1/2}$, the procedure to compute face flux now becomes:
\begin{enumerate}
    \item Identify the upstream direction based on $u_f^{n+1/2}$.
    \item Choose corresponding cell to compute face flux based on equation \ref{equ:upwindfinal} and upstream direction obtained in previous step.
    \item According to equation \ref{equ:upwind} \ref{equ:upwind2}, add contribution from each direction and multiply the result by $u_f^{n+1/2}$ to obtain $u_f^{n+1/2}\Phi_f^{n+1/2}$.
\end{enumerate}
Yet another detail worth mentioning is the source term $a^n$ in current function. This is indeed preparation for solving non-Euler equation such as NS equation in 'centered.h'. Albeit compulsory here, such term is overall optional in the final function \func{advection} which shall be introduced in the upcoming section.
\subsubsection{Program Workflow}
\begin{multicols}{2}
  \begin{tikzpicture}
    \node [block](init){
        \textbf{Starting Point}\\
        \textbf{input}: \\
        \para{f} = $\Phi^n$ \para{uf} = $u_f^{n+ \frac{1}{2}}$\\ \para{flux}(empty) \para{dt}=$\Delta t$\\ \para{src} = $ \mathbf{g}^n$\\
        \textbf{gradient}:\\
        \para{g} = $\nabla$ \para{f} = $\nabla \Phi$
      };
  \end{tikzpicture}
 \columnbreak
 \begin{minted}{cpp}
void tracer_fluxes (scalar f,
		    face vector uf,
		    face vector flux,
		    double dt,
		    (const) scalar src)
{
  vector g[];
  gradients ({f}, {g});
 \end{minted}
 
\end{multicols}

\begin{center}
  \begin{tikzpicture}
    \draw[-latex,thick](0,0) -- (0,-1); 
  \end{tikzpicture}
\end{center}

\begin{multicols}{2}
  \begin{tikzpicture}
    \node [block](init){
        \textbf{compute un}\footnote{A compensation is made here, see \ref{sec:tracerdetail} for detailed information}: \\
        \para{un}=$\frac{u_{f,d}^{n+1/2}\Delta t}{fm.x[i]\Delta}$\\
        \textbf{Identification of upstream direction}\\
        The notation of corresponding cell \para{i} is identified according to equation \ref{equ:upwindfinal2}.
        \para{s} = $s_d$\\
      };
  \end{tikzpicture}
  \columnbreak
  \begin{minted}{cpp}
  foreach_face() {
    double un = dt*uf.x[]/(fm.x[]*Delta + SEPS), s = sign(un);
    int i = -(s + 1.)/2.;

  \end{minted}
\end{multicols}

\begin{center}
  \begin{tikzpicture}
    \draw[-latex,thick](0,0) -- (0,-1); 
  \end{tikzpicture}
\end{center}

\begin{multicols}{2}
  \begin{tikzpicture}
    \node [block](init){
        \textbf{Contribution of Each Direction}\\
        \textbf{Main direction}\\
        \para{f2} = $\Phi^n[i] + \frac{\Delta}{2}[s_d- \frac{\Delta t}{\Delta}u_{f,d}^{n+1/2}] \frac{\partial \Phi^n}{\partial x_d}[i]$\\
        $+\frac{\Delta t}{2}\frac{a^n[-1]+a^n[0]}{2}$\\ 
        \textbf{Traversal direction}\\
        \textbf{compute $u_o$ in equation \ref{equ:upwind}}: \\
        \para{vn}(\para{wn})=$(u^{n+1/2}_{f,o}[i,0]+u^{n+1/2}_{f,o}[i,1])/(fm.e[i,0]+fm.e[i,1])$\\
        \textbf{component of other direction}:\\
        The gradient $\overline{\frac{\partial \Phi^n}{\partial x_o}}$ is first computed by upwind scheme based on direction of $u_o$ according to equation \ref{equ:upwind2}\\
        \para{fyy}(\para{fzz})= $\overline{\frac{\partial \Phi^n}{\partial x_o}}$\\
        \para{f2} -= $\frac{\Delta t}{2} u_o \overline{\frac{\partial \Phi^n}{\partial x_o}}$ 
      };
  \end{tikzpicture}
  \columnbreak
  \begin{minted}{cpp}
    double f2 = f[i] + (src[] + src[-1])*dt/4. + s*(1. - s*un)*g.x[i]*Delta/2.;
    #if dimension > 1
    if (fm.y[i] && fm.y[i,1]) {
      double vn = (uf.y[i] + uf.y[i,1])/(fm.y[i] + fm.y[i,1]);
      double fyy = vn < 0. ? f[i,1] - f[i] : f[i] - f[i,-1];
      f2 -= dt*vn*fyy/(2.*Delta);
    }
    #endif
    #if dimension > 2
    if (fm.z[i] && fm.z[i,0,1]) {
      double wn = (uf.z[i] + uf.z[i,0,1])/(fm.z[i] + fm.z[i,0,1]);
      double fzz = wn < 0. ? f[i,0,1] - f[i] : f[i] - f[i,0,-1];
      f2 -= dt*wn*fzz/(2.*Delta);
    }
    #endif
  \end{minted}
\end{multicols}

\begin{center}
  \begin{tikzpicture}
    \draw[-latex,thick](0,0) -- (0,-1); 
  \end{tikzpicture}
\end{center}

\begin{multicols}{2}
  \begin{tikzpicture}
    \node [block](init){
        \textbf{Assemble}\\
        assemble the final result, current direction is $d$\\
        \para{flux.d}=$u_{f,d}^{n+ \frac{1}{2}}\Phi_{f,d}^{n+ \frac{1}{2}}$\\
        after the $foreach\_face$ macro, the face flux on every face is obtained.
      };
  \end{tikzpicture}
  \columnbreak
  \begin{minted}{cpp}
    flux.x[] = f2*uf.x[];
  }
}
  \end{minted}
\end{multicols}

\subsection{\func{advection}}

\subsubsection{Parameters}
\begin{center}
  \begin{tabular}{|c|c|c|c|c|}
    \hline
    Name & Data type & Status & Option & Representation (before/after)\\[0.5ex]
    \hline\hline
    \rowcolor{output} \para{tracers} & scalar* & update & compulsory & $\Phi^n$/ $\Phi^n-\Delta t A^{n+ \frac{1}{2}}$\\
    \hline
    \para{u} & face vector & unchanged & compulsory & $u_d^{n+ \frac{1}{2}}$\\
    \hline
    \para{dt} & double & unchanged & compulsory & $\Delta t$\\
    \hline
    \para{src} & scalar* & unchanged & optional & $ \mathbf{g}^n$ \\
    \hline
  \end{tabular}
\end{center}

\subsubsection{Worth Mentioning Details}\label{sec:direction}
The input of this function (\para{tracers},\para{src}) can be $vector$ type, e.g. $\mathbf{u}$, where components of each direction is deemed as $scalar$ type data then is finally assembled as a $vector$.\par
Another thing needs to be concerned is the direction of the normal unity associates with coordinate axis. Positive direction of coordinate remains unchanged will face normal direction varies with respect to current cell. Take Fig.\ref{fig:facenormal} as an example. 
\begin{figure}[H]
  \centering
    \begin{tikzpicture}[scale=1]
    \draw[->] (-3,0) -- (3,0) node[anchor=north west] {x};%画出x轴并将最后的终结点其命名为x
    \draw[->] (0,-1) -- (0,3) node[anchor=south east] {y};%画出y轴并将最后的终结点其命名为y
    \draw[very thick,red]
        (0,0) -- (0,2.5);%在线段的中间添加标签，并使用fill = white使线条不透过标签
    \draw (-2.5,0) -- (-2.5,2.5)--(2.5,2.5)--(2.5,0);
    \fill [color = red] (0,1.25) circle (2pt) ;
    \fill (1.25,1.25) circle (2pt) node[above=2pt,fill=white]{$A$};
    \fill (-1.25,1.25) circle (2pt) node[above=2pt,fill=white]{$B$};
    \end{tikzpicture}
    \caption{Face normal example.}
    \label{fig:facenormal}
\end{figure}
For cell $A$, direction of highlighted face is opposite to coordinate while positive for that of cell $B$. For the sake of clarity and convenience, all value involved compute in function \func{tracer\_fluxes} take default positive direction. Which means for further computation for $\sum_{i=d}u_d^{n+ \frac{1}{2}}\Phi_d^{n+ \frac{1}{2}}$ of cell $A$, the value added at highlighted face should take negative value reads 
\begin{equation}
  u_d^{n+ \frac{1}{2}}\Phi_d^{n + \frac{1}{2}}(i)+u_d^{n+ \frac{1}{2}}\Phi_d^{n + \frac{1}{2}}(i+1) = -flux.x[i]+flux.x[i+1]
\end{equation}

\newpage
\subsubsection{Program Workflow}
\begin{multicols}{2}
  \begin{tikzpicture}
    \node [block](init){
        \textbf{Starting Point}\\
        \textbf{input}: \\
        \para{tracers} = $\Phi^n$ \para{u} = $u_d^{n+ \frac{1}{2}}$\\ \para{dt}=$\Delta t$ \para{src} = $ \mathbf{g}^n$\\
      };
  \end{tikzpicture}
  \columnbreak
  \begin{minted}{cpp}
    struct Advection {
      scalar * tracers;
      face vector u;
      double dt;
      scalar * src; // optional
    };
    void advection (struct Advection p)
    {
      scalar * lsrc = p.src;
      if (!lsrc)
        for (scalar s in p.tracers)
          lsrc = list_append (lsrc, zeroc);
      assert (list_len(p.tracers) == list_len(lsrc));
  \end{minted}
\end{multicols}

\begin{center}
  \begin{tikzpicture}
    \draw[-latex,thick](0,0) -- (0,-1); 
  \end{tikzpicture}
\end{center}

\begin{multicols}{2}
  \begin{tikzpicture}
    \node [block](init){
        \textbf{Fluxes Compute}\\
        Traversal each elements in \para{tracers} (if \para{tracers} is vector, then this step traversal component on every direction)\\
        \textbf{computation}: \\
        \para{flux} = $\Phi^{n+ \frac{1}{2}}_d u_d^{n+ \frac{1}{2}}$\\
      };
  \end{tikzpicture}
  \columnbreak
  \begin{minted}{cpp}
  scalar f, src;
  for (f,src in p.tracers,lsrc) {
    face vector flux[];
    tracer_fluxes (f, p.u, flux, p.dt, src);
  \end{minted}
\end{multicols}

\begin{center}
  \begin{tikzpicture}
    \draw[-latex,thick](0,0) -- (0,-1); 
  \end{tikzpicture}
\end{center}


\begin{multicols}{2}
  \begin{tikzpicture}
    \node [block](init){
        \textbf{Update}\\
        \para{tracers}(updated) = $\Phi^{n+1}$ = $\Phi^n-\Delta t A^{n+ \frac{1}{2}}$\\
        = $\Phi^n- \Delta t \sum u_d^{n+ \frac{1}{2}}\Phi_d^{n + \frac{1}{2}}$
        = $f[] + \Delta t \sum_{each\_di} (flux.d[i]-flux.d[i-1])$
      };
  \end{tikzpicture}
  \columnbreak
  \begin{minted}{cpp}
    #if !EMBED
        foreach()
          foreach_dimension()
            f[] += p.dt*(flux.x[] - flux.x[1])/(Delta*cm[]);
    #else // EMBED
        update_tracer (f, p.u, flux, p.dt);//This is a function that induced by embed.h which conducts same procedure with special care taken for embed boundary.
    #endif // EMBED
      }

      if (!p.src)
        free (lsrc);
    }
  \end{minted}
\end{multicols}

\appendix
\section{Calculation of Face Centered Normal Velocity}
It can be seen from \ref{sec:intro}, the computation of face centered normal velocity $u_d^{n+ \frac{1}{2}}$ is of great importance to construct advection term. The detailed procedure of extrapolation is shown in documentation of \textbf{centered.h}. The output of such variable follows a similar step as equation \ref{equ:taylor} but without pressure term since the face centered velocity will be projected with an edge-centered projection. This additional projection ensures the feature of conservative of corresponding method.\par
When it comes to the resolution of NS equation, $\Phi$ in governing equation \ref{equ:aim} is the cell-centered vector $ \mathbf{u}^n$. According to Martin\cite{martin2000cell}, normal components calculated by equation \ref{equ:taylor} can simply be replaced by $u_d^{n+ \frac{1}{2}}$, which means we only need to compute tangential fluxes. However, after series of tests, reuse of normal fluxes will lead to unstable at sharp angles. Thus all components is recomputed in Basilisk\cite{popinet2003gerris}.
\printbibliography
\end{document}
